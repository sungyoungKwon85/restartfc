<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>팀 자동 라인업</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      padding: 12px;
      max-width: 1200px;
      margin: 0 auto;
    }
    h1 {
      font-size: 20px;
      margin-bottom: 8px;
    }
    h2 {
      font-size: 18px;
      margin-top: 20px;
      margin-bottom: 6px;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px 16px;
      align-items: center;
      margin-bottom: 16px;
      padding: 8px;
      border-radius: 8px;
      background: #f5f5f5;
    }
    label {
      font-size: 12px;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }
    select, input[type="number"], input[type="text"] {
      font-size: 12px;
    }
    button {
      padding: 8px 14px;
      border-radius: 8px;
      border: none;
      font-size: 14px;
      background: #2b7cff;
      color: white;
      font-weight: 600;
      cursor: pointer;
    }
    button:active {
      transform: scale(0.98);
    }
    .btn-secondary {
      background: #6b7280;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      font-size: 12px;
    }
    th, td {
      border: 1px solid #ddd;
      padding: 4px 6px;
      text-align: center;
    }
    th {
      background: #fafafa;
    }
    .players-table {
      max-height: 260px;
      overflow: auto;
      border: 1px solid #ddd;
      border-radius: 6px;
      margin-bottom: 8px;
    }
    .q-wrapper {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 12px;
      margin-top: 8px;
    }
    .q-card {
      border-radius: 8px;
      padding: 6px;
      background: #f9fafb;
      border: 1px solid #e5e7eb;
    }
    .q-card h3 {
      font-size: 14px;
      margin: 0 0 4px;
    }
    .badge {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 999px;
      font-size: 10px;
      background: #e5e7eb;
      margin-left: 4px;
    }
    .note {
      font-size: 11px;
      color: #666;
      margin-top: 4px;
    }
    .text-right {
      text-align: right;
    }
    .icon-btn {
      border: none;
      background: transparent;
      cursor: pointer;
      padding: 2px 4px;
      font-size: 12px;
      color: #9ca3af;
    }
    .icon-btn:hover {
      color: #ef4444;
    }

    /* 포메이션 그라운드 뷰 */
    .pitch {
      margin-top: 6px;
      padding: 4px;
      border-radius: 8px;
      background: #020617;
      background-image: linear-gradient(to bottom, rgba(148,163,184,0.15) 1px, transparent 1px),
                        linear-gradient(to right, rgba(148,163,184,0.15) 1px, transparent 1px);
      background-size: 18px 18px;
      color: #e5e7eb;
      font-size: 10px;
    }
    .pitch-row {
      display: flex;
      justify-content: center;
      margin: 2px 0;
    }
    .pitch-cell {
      min-width: 46px;
      min-height: 22px;
      border-radius: 4px;
      border: 1px solid rgba(148,163,184,0.6);
      margin: 0 2px;
      padding: 2px 4px;
      text-align: center;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }
    .pitch-pos {
      opacity: 0.7;
      font-size: 9px;
      line-height: 1.1;
    }
    .pitch-name {
      font-size: 10px;
      font-weight: 600;
      line-height: 1.1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    @media (max-width: 600px) {
      body { padding: 8px; }
      .controls { flex-direction: column; align-items: flex-start; }
    }
  </style>
</head>
<body>
  <h1>팀 자동 라인업</h1>

  <!-- 상단 설정 영역 -->
  <div class="controls">
    <label>
      쿼터 수
      <select id="numQuarters">
        <option value="4" selected>4쿼터</option>
        <option value="5">5쿼터</option>
      </select>
    </label>

    <label>
      출전 인원 (한 팀)
      <select id="playersPerSide">
        <option value="10">10 : 10</option>
        <option value="11" selected>11 : 11</option>
      </select>
    </label>

    <label>
      1쿼 포메이션
      <select id="fQ1"></select>
    </label>
    <label>
      2쿼 포메이션
      <select id="fQ2"></select>
    </label>
    <label>
      3쿼 포메이션
      <select id="fQ3"></select>
    </label>
    <label>
      4쿼 포메이션
      <select id="fQ4"></select>
    </label>
    <label>
      5쿼 포메이션
      <select id="fQ5"></select>
    </label>

    <label>
      <input type="checkbox" id="sameFormation" checked />
      모든 쿼터 동일 포메이션
    </label>

    <button onclick="generateLineup()">라인업 생성</button>
  </div>

  <!-- 포지션 자동완성용 datalist -->
  <datalist id="positionList">
    <option value="GK"></option>
    <option value="CB"></option>
    <option value="WB"></option>
    <option value="MF"></option>
    <option value="W"></option>
    <option value="CF"></option>
  </datalist>

  <!-- 선수 설정 표 -->
  <h2>선수 / 출전 설정</h2>
  <div class="players-table">
    <table id="playersTable">
      <thead>
        <tr>
          <th>참석</th>
          <th>이름</th>
          <th>1순위</th>
          <th>2순위</th>
          <th>3순위</th>
          <th>컨디션</th>
          <th>목표 쿼터</th>
          <th>시작Q</th>
          <th>종료Q</th>
          <th></th>
        </tr>
      </thead>
      <tbody>
      <!-- JS에서 채움 -->
      </tbody>
    </table>
  </div>
  <div class="text-right" style="margin-bottom:4px;">
    <button class="btn-secondary" onclick="addPlayer()">선수 추가(용병 포함)</button>
    <button class="btn-secondary" onclick="resetPlayers()">메타데이터 초기화(브라우저 캐시 삭제)</button>
  </div>
  <div class="text-right" style="margin-bottom:4px;">
    <button class="btn-secondary" onclick="setAllCondition(1)">컨디션 전체 1(좋음)</button>
    <button class="btn-secondary" onclick="setAllCondition(2)">컨디션 전체 2(보통)</button>
    <button class="btn-secondary" onclick="setAllCondition(3)">컨디션 전체 3(나쁨)</button>
    <button class="btn-secondary" onclick="setAllTargetQ(3)">목표 쿼터 전체 3Q</button>
  </div>
  <div class="note">
    · 참석 체크박스는 기본적으로 모두 꺼진 상태입니다. 오는 사람만 체크하세요.<br>
    · 포지션은 GK / CB / WB / MF / W / CF 중에서 **1~3순위**를 설정합니다. 다른 포지션은 기본적으로 자동 배치하지 않습니다.<br>
    · 목표 쿼터는 0.5 단위 입력 가능하며, 기본값은 3Q입니다. 실제 배치는 쿼터 단위(1Q) 기준입니다.<br>
    · 지각/조퇴는 시작Q/종료Q로 조정합니다. 예: 1.5 → 2Q부터, 3.5 → 3Q까지만.<br>
    · 컨디션이 나쁠수록 1-2-3 / 2-3-4 같은 연속 쿼터 배치를 최대한 피하려고 시도합니다.
  </div>

  <!-- 결과 영역 -->
  <h2>쿼터별 라인업 결과</h2>
  <div id="summary" class="note"></div>
  <div id="playerQuarters" class="note"></div>
  <div class="q-wrapper" id="quartersContainer">
    <!-- JS에서 각 쿼터 카드 생성 -->
  </div>

<script>
/* =========================
   1. 메타데이터 (선수 & 포지션 & 포메이션)
   ========================= */

const initialPlayersTemplate = [
  { name: "지환",   main: "GK", sub1: "",   sub2: ""   },
  { name: "이재현", main: "GK", sub1: "WB", sub2: "CB" },

  { name: "시원",   main: "CB", sub1: "CB", sub2: "WB" },
  { name: "희환",   main: "CB", sub1: "WB", sub2: "MF" },
  { name: "성일",   main: "CB", sub1: "CB", sub2: "WB" },

  { name: "연수",   main: "WB", sub1: "MF", sub2: "WB" },
  { name: "성영",   main: "WB", sub1: "CB", sub2: "W"  },
  { name: "규민",   main: "WB", sub1: "W",  sub2: "WB" },
  { name: "영현",   main: "WB", sub1: "W",  sub2: "WB" },
  { name: "병진",   main: "WB", sub1: "CF", sub2: "MF" },

  { name: "호균",   main: "MF", sub1: "MF", sub2: "CB" },
  { name: "명렬",   main: "MF", sub1: "WB", sub2: "CB" },
  { name: "용락",   main: "MF", sub1: "MF", sub2: "CB" },
  { name: "영철",   main: "MF", sub1: "CF", sub2: "MF" },
  { name: "승현",   main: "MF", sub1: "MF", sub2: "MF" },
  { name: "김재현", main: "MF", sub1: "MF", sub2: "CB" },
  { name: "봉준",   main: "MF", sub1: "MF", sub2: "CB" },
  { name: "종규",   main: "MF", sub1: "MF", sub2: "W"  },

  { name: "상준",   main: "W",  sub1: "W",  sub2: "MF" },
  { name: "태호",   main: "W",  sub1: "W",  sub2: "MF" },
  { name: "수형",   main: "W",  sub1: "MF", sub2: "W"  },
  { name: "광경",   main: "W",  sub1: "W",  sub2: "WB" },

  { name: "성원",   main: "CF", sub1: "MF", sub2: "W"  },
  { name: "시훈",   main: "CF", sub1: "CF", sub2: "CB" },
  { name: "현일",   main: "CF", sub1: "CF", sub2: "CB" }
];

// localStorage key (버전 올림: v11)
const STORAGE_KEY = "restartfc_players_v11";

// 사용 가능한 포메이션 목록 (백 수 + 전개, 10명/11명)
const AVAILABLE_FORMATIONS = {
  11: [
    { id: "4-3-3",   label: "4-3-3 (4백)" },
    { id: "4-2-3-1", label: "4-2-3-1 (4백)" },
    { id: "4-1-4-1", label: "4-1-4-1 (4백)" },
    { id: "3-4-3",   label: "3-4-3 (3백)" },
    { id: "3-5-2",   label: "3-5-2 (3백)" }
  ],
  10: [
    { id: "4-3-2",   label: "4-3-2 (4백)" },
    { id: "4-2-3",   label: "4-2-3 (4백)" },
    { id: "3-5-1",   label: "3-5-1 (3백)" },
    { id: "3-4-2",   label: "3-4-2 (3백)" }
  ]
};

// 실제 포지션 배치 (GK, CB, WB, MF, W, CF)
const FORMATIONS = {
  // 11명 포메이션
  "11_4-3-3": {
    label: "4-3-3",
    grid: [
      [ null, "CF",  null ],
      [ "W",  null,  "W"  ],
      [ "MF", "MF",  "MF" ],
      [ "WB", "CB",  "CB", "WB" ],
      [ null, "GK",  null ]
    ]
  },
  "11_4-2-3-1": {
    label: "4-2-3-1",
    grid: [
      [ null, "CF",  null ],
      [ "W",  "MF",  "W"  ],   // 3명의 2선 공격수 (W/MF/W)
      [ "MF", null,  "MF" ],  // 2명의 수비형 MF
      [ "WB", "CB",  "CB", "WB" ],
      [ null, "GK",  null ]
    ]
  },
  "11_4-1-4-1": {
    label: "4-1-4-1",
    grid: [
      [ null, "CF",  null ],
      [ "W",  "MF",  "W"  ],   // 측면 + 중앙 공격 MF
      [ null,"MF", "MF",null], // 중앙 MF (2명)
      [ "WB", "CB",  "CB", "WB" ],
      [ null, "GK",  null ]
    ]
  },
  "11_3-4-3": {
    label: "3-4-3",
    grid: [
      [ null, "CF",  null ],
      [ "W",  null,  "W"  ],
      [ "MF", "MF",  "MF", "MF" ],
      [ null, "CB",  "CB", "CB" ],
      [ null, "GK",  null ]
    ]
  },
  "11_3-5-2": {
    label: "3-5-2",
    grid: [
      [ "CF", null, "CF" ],
      [ "W",  "MF", "MF", "W" ],
      [ null, "MF", null ],
      [ null, "CB", "CB", "CB" ],
      [ null, "GK", null ]
    ]
  },

  // 10명 포메이션
  "10_4-3-2": {
    label: "4-3-2",
    grid: [
      [ "CF", null, "CF" ],
      [ "W",  "MF", "W"  ],
      [ "WB", "CB", "CB", "WB" ],
      [ null, "GK", null ]
    ]
  },
  "10_4-2-3": {
    label: "4-2-3",
    grid: [
      [ null, "CF",  null ],
      [ "W",  null,  "W"  ],
      [ "MF", null,  "MF" ],
      [ "WB", "CB",  "CB", "WB" ],
      [ null, "GK",  null ]
    ]
  },
  "10_3-5-1": {
    label: "3-5-1",
    grid: [
      [ null, "CF",  null ],
      [ "MF", "MF", "MF", "MF", "MF" ],
      [ null, "CB", "CB", "CB" ],
      [ null, "GK", null ]
    ]
  },
  "10_3-4-2": {
    label: "3-4-2",
    grid: [
      [ "CF", null, "CF" ],
      [ "MF", "MF", "MF", "MF" ],
      [ null, "CB", "CB", "CB" ],
      [ null, "GK", null ]
    ]
  }
};

const POSITION_CATEGORY_ORDER = ["GK","CB","WB","MF","W","CF"];
const DEFAULT_TARGET_Q = 3;

let totalQuarters = 4;
let players = [];
let currentSlots = [];                    // {quarter,row,col,position,playerIndex}
let currentFormationKeyByQuarter = {};    // {q: key}

/* =========================
   2. 유틸
   ========================= */

function posCategory(pos) {
  if (!pos) return "";
  pos = pos.toUpperCase();
  return POSITION_CATEGORY_ORDER.includes(pos) ? pos : "";
}

function getPositionRank(pos) {
  const cat = posCategory(pos);
  const idx = POSITION_CATEGORY_ORDER.indexOf(cat);
  return idx === -1 ? 999 : idx;
}

function resolveFormationKey(playersPerSide, formationId) {
  return `${playersPerSide}_${formationId}`;
}

/* =========================
   3. 선수 데이터 로딩 / 저장
   ========================= */

function loadPlayersFromStorage() {
  try {
    const raw = window.localStorage.getItem(STORAGE_KEY);
    if (!raw) return null;
    const parsed = JSON.parse(raw);
    if (!Array.isArray(parsed)) return null;
    return parsed;
  } catch (e) {
    console.warn("loadPlayers error", e);
    return null;
  }
}

function savePlayersToStorage() {
  try {
    const toSave = players.map(p => ({
      name: p.name,
      main: p.main,
      sub1: p.sub1,
      sub2: p.sub2,
      present: p.present,
      targetQ: p.targetQ,
      startQ: p.startQ,
      endQ: p.endQ,
      condition: p.condition
    }));
    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(toSave));
  } catch (e) {
    console.warn("savePlayers error", e);
  }
}

/* =========================
   4. 화면 초기 렌더링
   ========================= */

function updateTotalQuartersFromUI() {
  const select = document.getElementById("numQuarters");
  totalQuarters = select ? Number(select.value) || 4 : 4;
}

function init() {
  const stored = loadPlayersFromStorage();
  const base = stored && stored.length > 0 ? stored : initialPlayersTemplate;

  players = base.map(p => ({
    name: p.name || "",
    main: (p.main || "").toUpperCase(),
    sub1: (p.sub1 || "").toUpperCase(),
    sub2: (p.sub2 || "").toUpperCase(),
    present: p.present !== undefined ? !!p.present : false,
    targetQ: p.targetQ !== undefined ? Number(p.targetQ) || DEFAULT_TARGET_Q : DEFAULT_TARGET_Q,
    startQ: p.startQ !== undefined ? Number(p.startQ) || 1 : 1,
    endQ: p.endQ !== undefined ? Number(p.endQ) || 4 : 4,
    condition: p.condition !== undefined ? Number(p.condition) || 2 : 2, // 1~3, 기본 2
    allocatedQuarters: 0
  }));

  updateTotalQuartersFromUI();
  initFormationSelects();
  renderPlayersTable();
  renderQuarterCards();
  setupFormationLink();
}

function initFormationSelects() {
  const playersPerSide = Number(document.getElementById("playersPerSide").value) || 11;
  const list = AVAILABLE_FORMATIONS[playersPerSide] || AVAILABLE_FORMATIONS[11];
  const defaultId = playersPerSide === 10 ? "4-2-3" : "4-3-3";

  const ids = ["fQ1","fQ2","fQ3","fQ4","fQ5"];
  ids.forEach(id => {
    const sel = document.getElementById(id);
    if (!sel) return;
    sel.innerHTML = "";
    list.forEach(f => {
      const opt = document.createElement("option");
      opt.value = f.id;
      opt.textContent = f.label;
      if (f.id === defaultId) opt.selected = true;
      sel.appendChild(opt);
    });
  });
}

function renderPlayersTable() {
  const tbody = document.querySelector("#playersTable tbody");
  tbody.innerHTML = "";

  const sorted = [...players].sort((a, b) => {
    const ra = getPositionRank(a.main);
    const rb = getPositionRank(b.main);
    if (ra !== rb) return ra - rb;
    return (a.name || "").localeCompare(b.name || "", "ko");
  });

  sorted.forEach((p) => {
    const tr = document.createElement("tr");

    // 참석
    const tdPresent = document.createElement("td");
    const chk = document.createElement("input");
    chk.type = "checkbox";
    chk.checked = p.present;
    chk.onchange = () => {
      p.present = chk.checked;
      savePlayersToStorage();
    };
    tdPresent.appendChild(chk);
    tr.appendChild(tdPresent);

    // 이름
    const tdName = document.createElement("td");
    const inputName = document.createElement("input");
    inputName.type = "text";
    inputName.value = p.name;
    inputName.style.width = "80px";
    inputName.oninput = () => {
      p.name = inputName.value.trim();
      savePlayersToStorage();
    };
    tdName.appendChild(inputName);
    tr.appendChild(tdName);

    // 1,2,3순위 포지션
    ["main","sub1","sub2"].forEach(key => {
      const td = document.createElement("td");
      const inputPos = document.createElement("input");
      inputPos.type = "text";
      inputPos.setAttribute("list", "positionList");
      inputPos.value = p[key] || "";
      inputPos.style.width = "60px";
      inputPos.oninput = () => {
        const val = inputPos.value.trim().toUpperCase();
        p[key] = POSITION_CATEGORY_ORDER.includes(val) ? val : "";
        savePlayersToStorage();
        renderPlayersTable();
      };
      td.appendChild(inputPos);
      tr.appendChild(td);
    });

    // 컨디션
    const tdCond = document.createElement("td");
    const selCond = document.createElement("select");
    selCond.style.fontSize = "11px";
    ["1","2","3"].forEach(v => {
      const opt = document.createElement("option");
      opt.value = v;
      if (v === "1") opt.textContent = "1(좋음)";
      if (v === "2") opt.textContent = "2(보통)";
      if (v === "3") opt.textContent = "3(나쁨)";
      if (Number(v) === (p.condition || 2)) opt.selected = true;
      selCond.appendChild(opt);
    });
    selCond.onchange = () => {
      p.condition = Number(selCond.value) || 2;
      savePlayersToStorage();
    };
    tdCond.appendChild(selCond);
    tr.appendChild(tdCond);

    // 목표 쿼터
    const tdTarget = document.createElement("td");
    const inputTarget = document.createElement("input");
    inputTarget.type = "number";
    inputTarget.step = "0.5";
    inputTarget.min = "0";
    inputTarget.value = p.targetQ;
    inputTarget.style.width = "50px";
    inputTarget.onchange = () => {
      p.targetQ = Number(inputTarget.value) || 0;
      savePlayersToStorage();
    };
    tdTarget.appendChild(inputTarget);
    tr.appendChild(tdTarget);

    // 시작Q (0.5 단위)
    const tdStart = document.createElement("td");
    const inputStart = document.createElement("input");
    inputStart.type = "number";
    inputStart.step = "0.5";
    inputStart.min = "1";
    inputStart.max = "5";
    inputStart.value = p.startQ;
    inputStart.style.width = "50px";
    inputStart.onchange = () => {
      let v = Number(inputStart.value) || 1;
      if (v < 1) v = 1;
      if (v > 5) v = 5;
      p.startQ = v;
      savePlayersToStorage();
    };
    tdStart.appendChild(inputStart);
    tr.appendChild(tdStart);

    // 종료Q (0.5 단위)
    const tdEnd = document.createElement("td");
    const inputEnd = document.createElement("input");
    inputEnd.type = "number";
    inputEnd.step = "0.5";
    inputEnd.min = "1";
    inputEnd.max = "5";
    inputEnd.value = p.endQ;
    inputEnd.style.width = "50px";
    inputEnd.onchange = () => {
      let v = Number(inputEnd.value) || 1;
      if (v < 1) v = 1;
      if (v > 5) v = 5;
      p.endQ = v;
      savePlayersToStorage();
    };
    tdEnd.appendChild(inputEnd);
    tr.appendChild(tdEnd);

    // 삭제 버튼
    const tdDel = document.createElement("td");
    const btnDel = document.createElement("button");
    btnDel.className = "icon-btn";
    btnDel.innerHTML = "✕";
    btnDel.title = "선수 삭제";
    btnDel.onclick = () => {
      if (confirm(`${p.name || "이 선수"}를 삭제할까요?`)) {
        const realIdx = players.indexOf(p);
        if (realIdx >= 0) {
          players.splice(realIdx, 1);
          savePlayersToStorage();
          renderPlayersTable();
        }
      }
    };
    tdDel.appendChild(btnDel);
    tr.appendChild(tdDel);

    tbody.appendChild(tr);
  });
}

function renderQuarterCards() {
  const container = document.getElementById("quartersContainer");
  container.innerHTML = "";
  for (let q = 1; q <= totalQuarters; q++) {
    const card = document.createElement("div");
    card.className = "q-card";
    card.id = `cardQ${q}`;
    const h3 = document.createElement("h3");
    h3.innerHTML = `${q}Q <span class="badge" id="badgeQ${q}"></span>`;
    card.appendChild(h3);

    const pitch = document.createElement("div");
    pitch.id = `pitchQ${q}`;
    pitch.className = "pitch";
    card.appendChild(pitch);

    container.appendChild(card);
  }
}

/* =========================
   5. 포메이션 연동 옵션
   ========================= */

function setupFormationLink() {
  const sameCheckbox = document.getElementById("sameFormation");
  const ids = ["fQ1","fQ2","fQ3","fQ4","fQ5"];
  const fQ1 = document.getElementById("fQ1");

  function applyToAll() {
    if (!sameCheckbox.checked) return;
    const base = fQ1.value;
    ids.slice(1).forEach(id => {
      const el = document.getElementById(id);
      if (el) el.value = base;
    });
  }

  if (fQ1) {
    fQ1.addEventListener("change", applyToAll);
  }
  if (sameCheckbox) {
    sameCheckbox.addEventListener("change", applyToAll);
  }

  applyToAll();

  const numQSelect = document.getElementById("numQuarters");
  if (numQSelect) {
    numQSelect.addEventListener("change", () => {
      updateTotalQuartersFromUI();
      renderQuarterCards();
      renderResult();
    });
  }

  const ppsSelect = document.getElementById("playersPerSide");
  if (ppsSelect) {
    ppsSelect.addEventListener("change", () => {
      initFormationSelects();
      applyToAll();
    });
  }
}

/* =========================
   6. 선수 추가 / 초기화 / 일괄 설정
   ========================= */

function addPlayer() {
  players.push({
    name: "",
    main: "",
    sub1: "",
    sub2: "",
    present: false,
    targetQ: DEFAULT_TARGET_Q,
    startQ: 1,
    endQ: 4,
    condition: 2,
    allocatedQuarters: 0
  });
  savePlayersToStorage();
  renderPlayersTable();
}

function resetPlayers() {
  if (!confirm("저장된 메타데이터(선수 정보, 포지션, 컨디션 등)를 모두 초기화할까요?")) return;
  window.localStorage.removeItem(STORAGE_KEY);
  init();
}

function setAllCondition(val) {
  players.forEach(p => {
    p.condition = val;
  });
  savePlayersToStorage();
  renderPlayersTable();
}

function setAllTargetQ(val) {
  players.forEach(p => {
    p.targetQ = val;
  });
  savePlayersToStorage();
  renderPlayersTable();
}

/* =========================
   7. 라인업 생성 로직 (2패스)
   ========================= */

function generateLineup() {
  updateTotalQuartersFromUI();

  const playersPerSide = Number(document.getElementById("playersPerSide").value);

  // 쿼터별 포메이션 ID 읽기
  const formationIdByQuarter = {};
  for (let q = 1; q <= totalQuarters; q++) {
    const select = document.getElementById(`fQ${q}`);
    formationIdByQuarter[q] = select ? select.value : (playersPerSide === 10 ? "4-2-3" : "4-3-3");
  }

  currentFormationKeyByQuarter = {};
  for (let q = 1; q <= totalQuarters; q++) {
    currentFormationKeyByQuarter[q] = resolveFormationKey(playersPerSide, formationIdByQuarter[q]);
  }

  players.forEach(p => { p.allocatedQuarters = 0; });

  const assignedByQuarter = {};
  for (let q = 1; q <= totalQuarters; q++) {
    assignedByQuarter[q] = new Set();
  }

  let lastGkIndex = null;
  currentSlots = [];

  // 1) 먼저 모든 슬롯 구조만 만든다
  for (let q = 1; q <= totalQuarters; q++) {
    const formKey = currentFormationKeyByQuarter[q];
    const form = FORMATIONS[formKey];
    if (!form) continue;
    const grid = form.grid;

    for (let r = 0; r < grid.length; r++) {
      const row = grid[r];
      for (let c = 0; c < row.length; c++) {
        const pos = row[c];
        if (!pos) continue;
        currentSlots.push({ quarter: q, row: r, col: c, position: pos, playerIndex: null });
      }
    }
  }

  // 2) 1~3순위 포지션에 맞춰 1차 배정
  currentSlots.forEach(slot => {
    const q = slot.quarter;
    const pos = slot.position;

    let bestIdx = -1;
    let bestScore = -1e15;

    players.forEach((p, idx) => {
      if (assignedByQuarter[q].has(idx)) return;
      const score = scorePlayerForSlotQuarter(p, idx, q, pos, lastGkIndex, false); // allowNonPreferred=false
      if (score > bestScore) {
        bestScore = score;
        bestIdx = idx;
      }
    });

    if (bestIdx >= 0 && bestScore > -1e10) {
      slot.playerIndex = bestIdx;
      players[bestIdx].allocatedQuarters += 1;
      assignedByQuarter[q].add(bestIdx);
      if (pos === "GK") lastGkIndex = bestIdx;
    }
  });

  // 3) 비어있는 슬롯은 컨디션 좋은 선수 우선으로 2차 배정 (포지션 무시 가능)
  currentSlots.forEach(slot => {
    if (slot.playerIndex != null) return; // 이미 배정됨

    const q = slot.quarter;
    const pos = slot.position;

    let bestIdx = -1;
    let bestScore = -1e15;

    players.forEach((p, idx) => {
      if (assignedByQuarter[q].has(idx)) return;
      const score = scorePlayerForSlotQuarter(p, idx, q, pos, lastGkIndex, true); // allowNonPreferred=true
      if (score > bestScore) {
        bestScore = score;
        bestIdx = idx;
      }
    });

    if (bestIdx >= 0 && bestScore > -1e10) {
      slot.playerIndex = bestIdx;
      players[bestIdx].allocatedQuarters += 1;
      assignedByQuarter[q].add(bestIdx);
      if (pos === "GK") lastGkIndex = bestIdx;
    }
  });

  updateStatsFromSlots();
  renderResult();
}

/**
 * 해당 선수의 이미 배정된 쿼터 목록
 */
function getPlayerAssignedQuarters(playerIndex) {
  const qs = new Set();
  currentSlots.forEach(s => {
    if (s.playerIndex === playerIndex) {
      qs.add(s.quarter);
    }
  });
  return Array.from(qs).sort((a, b) => a - b);
}

/**
 * 점수 계산
 *  - 1차 패스: 1~3순위 포지션만 허용
 *  - 2차 패스: 포지션 상관 없이, 컨디션 & 공평성 위주
 *  - GK는 가능하면 한 명이 계속, 없으면 포지션 무시하고 그래도 제일 맞는 사람
 */
function scorePlayerForSlotQuarter(p, playerIndex, quarter, position, lastGkIndex, allowNonPreferred) {
  if (!p.present) return -1e12;
  if (!p.name) return -1e12;

  // 0.5 단위 지각/조퇴 처리: 해당 쿼터가 [ceil(startQ), floor(endQ)] 범위 내여야 함
  const minQ = Math.ceil(p.startQ || 1);
  const maxQ = Math.floor(p.endQ || totalQuarters);
  if (quarter < minQ || quarter > maxQ) return -1e12;

  const targetQ = p.targetQ || 0;
  if (targetQ <= 0) return -1e12;

  const posCat = posCategory(position);
  const mainCat = posCategory(p.main);
  const sub1Cat = posCategory(p.sub1);
  const sub2Cat = posCategory(p.sub2);

  const isInPreferred =
    posCat &&
    (posCat === mainCat || posCat === sub1Cat || posCat === sub2Cat);

  let score = 0;

  // GK 처리 (최우선)
  if (position === "GK") {
    if (!allowNonPreferred && !isInPreferred) {
      // 1차 패스에서 GK 경험 없는 선수는 배제
      return -1e12;
    }

    if (p.main === "GK") score += 120;
    else if (p.sub1 === "GK" || p.sub2 === "GK") score += 80;
    else if (allowNonPreferred) {
      // 2차 패스: 어쩔 수 없이 GK가 없으면, 다른 포지션 중에서라도 선택
      score += 10;
    }

    let gkBase = 0;
    if (p.main === "GK") gkBase = 250;
    else if (p.sub1 === "GK" || p.sub2 === "GK") gkBase = 180;
    score += gkBase;

    // 같은 GK가 계속 가도록 보너스
    if (lastGkIndex === playerIndex) score += 100;
  } else {
    // 필드 포지션
    if (!isInPreferred && !allowNonPreferred) {
      // 1차 패스: 1~3순위에 없는 포지션은 배정하지 않음
      return -1e11;
    }

    if (isInPreferred) {
      if (posCat === mainCat) {
        score += 100;
      } else if (posCat === sub1Cat) {
        score += 75;
      } else if (posCat === sub2Cat) {
        score += 55;
      }
    } else if (allowNonPreferred) {
      // 2차 패스: 포지션 안 맞아도 최소한의 점수
      score += 10;
    }
  }

  // 목표 쿼터 대비 남은 쿼터 (공평하게 3,3 되도록)
  const allocated = p.allocatedQuarters || 0;
  const remain = targetQ - allocated;

  if (remain > 0) {
    score += remain * 40;   // 덜 뛴 선수 강하게 우선
  } else if (remain < 0) {
    score += remain * 30;   // 이미 많이 뛴 선수는 큰 페널티 (ex. 4 vs 2 상황 방지)
  }

  // 연속/근접 쿼터 출전 페널티 (GK 제외)
  if (position !== "GK") {
    const assignedQs = getPlayerAssignedQuarters(playerIndex);
    const cond = p.condition || 2; // 1(좋음)~3(나쁨)

    let nearCount = 0;
    assignedQs.forEach(q => {
      if (Math.abs(q - quarter) <= 1) nearCount++;
    });

    if (nearCount > 0) {
      // 컨디션이 나쁠수록, 근접 쿼터가 많을수록 더 큰 페널티
      score -= nearCount * cond * 20;
    }
  }

  // 2차 패스에서 컨디션 좋은 선수 우선 (특히 남는 쿼터: 4Q, 5Q 등)
  if (allowNonPreferred) {
    const cond = p.condition || 2; // 1이 가장 좋음
    const condScore = (4 - cond) * 30; // 1→90, 2→60, 3→30
    score += condScore;
  }

  return score;
}

/* =========================
   8. 결과 렌더링 + 수정 가능 셀
   ========================= */

function isPlayerUsedInQuarter(playerIndex, quarter, exceptSlot) {
  if (playerIndex == null) return false;
  return currentSlots.some(s =>
    s.quarter === quarter &&
    s !== exceptSlot &&
    s.playerIndex === playerIndex
  );
}

function updateStatsFromSlots() {
  players.forEach(p => { p.allocatedQuarters = 0; });
  currentSlots.forEach(s => {
    if (s.playerIndex != null) {
      const p = players[s.playerIndex];
      if (p) p.allocatedQuarters += 1;
    }
  });

  let totalTargetQ = 0;
  let totalAllocatedQ = 0;
  players.forEach(p => {
    if (!p.present || !p.name) return;
    totalTargetQ += (p.targetQ || 0);
    totalAllocatedQ += (p.allocatedQuarters || 0);
  });

  const summary = document.getElementById("summary");
  const diff = totalAllocatedQ - totalTargetQ;
  summary.innerHTML =
    `총 출전: ${totalAllocatedQ}Q / 목표: ${totalTargetQ}Q (차이: ${diff}Q)`;

  const playerQuartersDiv = document.getElementById("playerQuarters");
  const lines = [];
  players.forEach(p => {
    if (!p.present || !p.name) return;
    const qPlayed = p.allocatedQuarters || 0;
    lines.push(`${p.name}: ${qPlayed}Q / 목표 ${p.targetQ}Q (컨디션 ${p.condition})`);
  });
  playerQuartersDiv.textContent = lines.length
    ? `참석자별 출전 쿼터: ${lines.join(", ")}`
    : "";
}

function renderResult() {
  if (!currentSlots || currentSlots.length === 0) {
    for (let q = 1; q <= totalQuarters; q++) {
      const badge = document.getElementById(`badgeQ${q}`);
      const pitch = document.getElementById(`pitchQ${q}`);
      if (badge) badge.textContent = "";
      if (pitch) pitch.innerHTML = "";
    }
    return;
  }

  const slotMapByQuarter = {};
  for (let q = 1; q <= totalQuarters; q++) {
    slotMapByQuarter[q] = {};
  }

  currentSlots.forEach(s => {
    const key = `${s.row}_${s.col}`;
    if (!slotMapByQuarter[s.quarter]) {
      slotMapByQuarter[s.quarter] = {};
    }
    slotMapByQuarter[s.quarter][key] = s;
  });

  for (let q = 1; q <= totalQuarters; q++) {
    const formKey = currentFormationKeyByQuarter[q];
    const form = FORMATIONS[formKey];
    const pitch = document.getElementById(`pitchQ${q}`);
    const badge = document.getElementById(`badgeQ${q}`);

    if (!pitch || !badge) continue;

    if (!form) {
      badge.textContent = "";
      pitch.innerHTML = "";
      continue;
    }

    badge.textContent = form.label;
    pitch.innerHTML = "";

    const grid = form.grid;
    for (let r = 0; r < grid.length; r++) {
      const rowDiv = document.createElement("div");
      rowDiv.className = "pitch-row";
      for (let c = 0; c < grid[r].length; c++) {
        const pos = grid[r][c];
        const cell = document.createElement("div");
        cell.className = "pitch-cell";

        if (pos) {
          const key = `${r}_${c}`;
          const slot = slotMapByQuarter[q][key];

          const posDiv = document.createElement("div");
          posDiv.className = "pitch-pos";
          posDiv.textContent = pos;
          cell.appendChild(posDiv);

          const sel = document.createElement("select");
          sel.style.fontSize = "10px";
          sel.style.marginTop = "2px";

          const optEmpty = document.createElement("option");
          optEmpty.value = "";
          optEmpty.textContent = "-";
          sel.appendChild(optEmpty);

          players.forEach((p, idx) => {
            if (!p.present || !p.name) return;
            const opt = document.createElement("option");
            opt.value = String(idx);
            opt.textContent = p.name;
            if (slot && slot.playerIndex === idx) opt.selected = true;
            sel.appendChild(opt);
          });

          sel.onchange = () => {
            const prevIdx = slot.playerIndex;
            const newVal = sel.value === "" ? null : Number(sel.value);

            if (newVal !== null && isPlayerUsedInQuarter(newVal, q, slot)) {
              alert("같은 쿼터에 한 선수는 한 번만 배정 가능합니다.");
              sel.value = prevIdx == null ? "" : String(prevIdx);
              return;
            }

            slot.playerIndex = newVal;
            updateStatsFromSlots();
          };

          cell.appendChild(sel);
        }

        rowDiv.appendChild(cell);
      }
      pitch.appendChild(rowDiv);
    }
  }
}

/* =========================
   9. 초기 실행
   ========================= */
init();
</script>
</body>
</html>
