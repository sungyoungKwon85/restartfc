<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>아마추어 팀 자동 라인업</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      padding: 12px;
      max-width: 1200px;
      margin: 0 auto;
    }
    h1 {
      font-size: 20px;
      margin-bottom: 8px;
    }
    h2 {
      font-size: 18px;
      margin-top: 20px;
      margin-bottom: 6px;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px 16px;
      align-items: center;
      margin-bottom: 16px;
      padding: 8px;
      border-radius: 8px;
      background: #f5f5f5;
    }
    label {
      font-size: 12px;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }
    select, input[type="number"], input[type="text"] {
      font-size: 12px;
    }
    button {
      padding: 8px 14px;
      border-radius: 8px;
      border: none;
      font-size: 14px;
      background: #2b7cff;
      color: white;
      font-weight: 600;
      cursor: pointer;
    }
    button:active {
      transform: scale(0.98);
    }
    .btn-secondary {
      background: #6b7280;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      font-size: 12px;
    }
    th, td {
      border: 1px solid #ddd;
      padding: 4px 6px;
      text-align: center;
    }
    th {
      background: #fafafa;
    }
    .players-table {
      max-height: 260px;
      overflow: auto;
      border: 1px solid #ddd;
      border-radius: 6px;
      margin-bottom: 8px;
    }
    .q-wrapper {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 12px;
      margin-top: 8px;
    }
    .q-card {
      border-radius: 8px;
      padding: 6px;
      background: #f9fafb;
      border: 1px solid #e5e7eb;
    }
    .q-card h3 {
      font-size: 14px;
      margin: 0 0 4px;
    }
    .badge {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 999px;
      font-size: 10px;
      background: #e5e7eb;
      margin-left: 4px;
    }
    .note {
      font-size: 11px;
      color: #666;
      margin-top: 4px;
    }
    .text-right {
      text-align: right;
    }
    .icon-btn {
      border: none;
      background: transparent;
      cursor: pointer;
      padding: 2px 4px;
      font-size: 12px;
      color: #9ca3af;
    }
    .icon-btn:hover {
      color: #ef4444;
    }

    /* 포메이션 그라운드 뷰 */
    .pitch {
      margin-top: 6px;
      padding: 4px;
      border-radius: 8px;
      background: #020617;
      background-image: linear-gradient(to bottom, rgba(148,163,184,0.15) 1px, transparent 1px),
                        linear-gradient(to right, rgba(148,163,184,0.15) 1px, transparent 1px);
      background-size: 18px 18px;
      color: #e5e7eb;
      font-size: 10px;
    }
    .pitch-row {
      display: flex;
      justify-content: center;
      margin: 2px 0;
    }
    .pitch-cell {
      min-width: 46px;
      min-height: 22px;
      border-radius: 4px;
      border: 1px solid rgba(148,163,184,0.6);
      margin: 0 2px;
      padding: 2px 4px;
      text-align: center;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }
    .pitch-pos {
      opacity: 0.7;
      font-size: 9px;
      line-height: 1.1;
    }
    .pitch-name {
      font-size: 10px;
      font-weight: 600;
      line-height: 1.1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    @media (max-width: 600px) {
      body { padding: 8px; }
      .controls { flex-direction: column; align-items: flex-start; }
    }
  </style>
</head>
<body>
  <h1>아마추어 팀 자동 라인업</h1>

  <!-- 상단 설정 영역 -->
  <div class="controls">
    <label>
      출전 인원 (한 팀)
      <select id="playersPerSide">
        <option value="10">10 : 10</option>
        <option value="11" selected>11 : 11</option>
      </select>
    </label>

    <label>
      1쿼 포메이션
      <select id="fQ1">
        <option value="4-back" selected>4-back (10명=4-2-3, 11명=4-3-3)</option>
        <option value="3-back">3-back (10명=3-5-1, 11명=3-4-3)</option>
      </select>
    </label>
    <label>
      2쿼 포메이션
      <select id="fQ2">
        <option value="4-back" selected>4-back (10명=4-2-3, 11명=4-3-3)</option>
        <option value="3-back">3-back (10명=3-5-1, 11명=3-4-3)</option>
      </select>
    </label>
    <label>
      3쿼 포메이션
      <select id="fQ3">
        <option value="4-back">4-back (10명=4-2-3, 11명=4-3-3)</option>
        <option value="3-back" selected>3-back (10명=3-5-1, 11명=3-4-3)</option>
      </select>
    </label>
    <label>
      4쿼 포메이션
      <select id="fQ4">
        <option value="4-back">4-back (10명=4-2-3, 11명=4-3-3)</option>
        <option value="3-back" selected>3-back (10명=3-5-1, 11명=3-4-3)</option>
      </select>
    </label>

    <button onclick="generateLineup()">라인업 생성</button>
  </div>

  <!-- 포지션 자동완성용 datalist -->
  <datalist id="positionList">
    <option value="GK"></option>
    <option value="CB"></option>
    <option value="WB"></option>
    <option value="MF"></option>
    <option value="W"></option>
    <option value="CF"></option>
  </datalist>

  <!-- 선수 설정 표 -->
  <h2>선수 / 출전 설정</h2>
  <div class="players-table">
    <table id="playersTable">
      <thead>
        <tr>
          <th>참석</th>
          <th>이름</th>
          <th>주포지션</th>
          <th>서브1</th>
          <th>서브2</th>
          <th>목표 쿼터</th>
          <th>시작Q</th>
          <th>종료Q</th>
          <th></th>
        </tr>
      </thead>
      <tbody>
      <!-- JS에서 채움 -->
      </tbody>
    </table>
  </div>
  <div class="text-right" style="margin-bottom:4px;">
    <button class="btn-secondary" onclick="addPlayer()">선수 추가</button>
    <button class="btn-secondary" onclick="resetPlayers()">선수 초기화</button>
  </div>
  <div class="note">
    · 참석 체크박스는 기본적으로 모두 꺼진 상태입니다. 오는 사람만 체크하세요.<br>
    · 포지션은 GK / CB / WB / MF / W / CF 중에서 선택해 사용합니다.<br>
    · 목표 쿼터는 0.5 단위 입력 가능하지만, 현재 라인업 배정은 **쿼터 단위(1Q)** 기준입니다.<br>
    · 지각/조퇴는 시작Q/종료Q로 조정합니다.
  </div>

  <!-- 결과 영역 -->
  <h2>쿼터별 라인업 결과</h2>
  <div id="summary" class="note"></div>
  <div id="playerQuarters" class="note"></div>
  <div class="q-wrapper" id="quartersContainer">
    <!-- JS에서 각 쿼터 카드 생성 -->
  </div>

<script>
/* =========================
   1. 메타데이터 (선수 & 포지션 & 포메이션)
   ========================= */

const initialPlayersTemplate = [
  { name: "지환",   main: "GK", sub1: "",   sub2: ""   },
  { name: "이재현", main: "GK", sub1: "WB", sub2: "CB" },

  { name: "시원",   main: "CB", sub1: "CB", sub2: "WB" },
  { name: "희환",   main: "CB", sub1: "WB", sub2: "MF" },
  { name: "성일",   main: "CB", sub1: "CB", sub2: "WB" },

  { name: "연수",   main: "WB", sub1: "MF", sub2: "WB" },
  { name: "성영",   main: "WB", sub1: "CB", sub2: "W"  },
  { name: "규민",   main: "WB", sub1: "W",  sub2: "WB" },
  { name: "영현",   main: "WB", sub1: "W",  sub2: "WB" },

  { name: "호균",   main: "MF", sub1: "MF", sub2: "CB" },
  { name: "명렬",   main: "MF", sub1: "WB", sub2: "CB" },
  { name: "용락",   main: "MF", sub1: "MF", sub2: "CB" },
  { name: "영철",   main: "MF", sub1: "CF", sub2: "MF" },
  { name: "승현",   main: "MF", sub1: "MF", sub2: "MF" },
  { name: "김재현", main: "MF", sub1: "MF", sub2: "CB" },
  { name: "봉준",   main: "MF", sub1: "MF", sub2: "CB" },
  { name: "종규",   main: "MF", sub1: "MF", sub2: "W"  },

  { name: "상준",   main: "W",  sub1: "W",  sub2: "MF" },
  { name: "태호",   main: "W",  sub1: "W",  sub2: "MF" },
  { name: "수형",   main: "W",  sub1: "MF", sub2: "W"  },
  { name: "광경",   main: "W",  sub1: "W",  sub2: "WB" },

  { name: "성원",   main: "CF", sub1: "MF", sub2: "W"  },
  { name: "시훈",   main: "CF", sub1: "CF", sub2: "CB" },
  { name: "현일",   main: "CF", sub1: "CF", sub2: "CB" }
];

// localStorage key
const STORAGE_KEY = "restartfc_players_v9";

// 포메이션 정의 (각 칸은 독립 슬롯)
const FORMATIONS = {
  "4-back_11": {
    label: "4-3-3",
    grid: [
      [ null, "CF",  null ],
      [ "W",  null,  "W"  ],
      [ "MF", "MF",  "MF" ],
      [ "WB", "CB",  "CB", "WB" ],
      [ null, "GK",  null ]
    ]
  },
  "3-back_11": {
    label: "3-4-3",
    grid: [
      [ null, "CF",  null ],
      [ "W",  null,  "W"  ],
      [ "MF", "MF",  "MF", "MF" ],
      [ null, "CB",  "CB", "CB" ],
      [ null, "GK",  null ]
    ]
  },
  "4-back_10": {
    label: "4-2-3",
    grid: [
      [ null, "CF",  null ],
      [ "W",  null,  "W"  ],
      [ "MF", null,  "MF" ],
      [ "WB", "CB",  "CB", "WB" ],
      [ null, "GK",  null ]
    ]
  },
  "3-back_10": {
    label: "3-5-1",
    grid: [
      [ null, "CF",  null ],
      [ "MF", "MF", "MF", "MF", "MF" ],
      [ null, "CB", "CB", "CB" ],
      [ null, "GK", null ]
    ]
  }
};

const POSITION_CATEGORY_ORDER = ["GK","CB","WB","MF","W","CF"];

function posCategory(pos) {
  if (!pos) return "";
  pos = pos.toUpperCase();
  return POSITION_CATEGORY_ORDER.includes(pos) ? pos : "";
}

function getPositionRank(pos) {
  const cat = posCategory(pos);
  const idx = POSITION_CATEGORY_ORDER.indexOf(cat);
  return idx === -1 ? 999 : idx;
}

function resolveFormationKey(playersPerSide, baseType) {
  return `${baseType}_${playersPerSide}`;
}

/* =========================
   2. 선수 데이터 로딩 / 저장
   ========================= */

let players = [];
let currentSlots = [];                    // {quarter,row,col,position,playerIndex}
let currentFormationKeyByQuarter = {};    // {q: key}

function loadPlayersFromStorage() {
  try {
    const raw = window.localStorage.getItem(STORAGE_KEY);
    if (!raw) return null;
    const parsed = JSON.parse(raw);
    if (!Array.isArray(parsed)) return null;
    return parsed;
  } catch (e) {
    console.warn("loadPlayers error", e);
    return null;
  }
}

function savePlayersToStorage() {
  try {
    const toSave = players.map(p => ({
      name: p.name,
      main: p.main,
      sub1: p.sub1,
      sub2: p.sub2,
      present: p.present,
      targetQ: p.targetQ,
      startQ: p.startQ,
      endQ: p.endQ
    }));
    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(toSave));
  } catch (e) {
    console.warn("savePlayers error", e);
  }
}

/* =========================
   3. 화면 초기 렌더링
   ========================= */

function init() {
  const stored = loadPlayersFromStorage();
  const base = stored && stored.length > 0 ? stored : initialPlayersTemplate;

  players = base.map(p => ({
    name: p.name || "",
    main: (p.main || "").toUpperCase(),
    sub1: (p.sub1 || "").toUpperCase(),
    sub2: (p.sub2 || "").toUpperCase(),
    present: p.present !== undefined ? !!p.present : false,
    targetQ: p.targetQ !== undefined ? Number(p.targetQ) || 3 : 3,
    startQ: p.startQ !== undefined ? Number(p.startQ) || 1 : 1,
    endQ: p.endQ !== undefined ? Number(p.endQ) || 4 : 4,
    allocatedQuarters: 0
  }));

  renderPlayersTable();
  renderQuarterCards();
}

function renderPlayersTable() {
  const tbody = document.querySelector("#playersTable tbody");
  tbody.innerHTML = "";

  const sorted = [...players].sort((a, b) => {
    const ra = getPositionRank(a.main);
    const rb = getPositionRank(b.main);
    if (ra !== rb) return ra - rb;
    return (a.name || "").localeCompare(b.name || "", "ko");
  });

  sorted.forEach((p) => {
    const tr = document.createElement("tr");

    const tdPresent = document.createElement("td");
    const chk = document.createElement("input");
    chk.type = "checkbox";
    chk.checked = p.present;
    chk.onchange = () => {
      p.present = chk.checked;
      savePlayersToStorage();
    };
    tdPresent.appendChild(chk);
    tr.appendChild(tdPresent);

    const tdName = document.createElement("td");
    const inputName = document.createElement("input");
    inputName.type = "text";
    inputName.value = p.name;
    inputName.style.width = "80px";
    inputName.oninput = () => {
      p.name = inputName.value.trim();
      savePlayersToStorage();
    };
    tdName.appendChild(inputName);
    tr.appendChild(tdName);

    ["main","sub1","sub2"].forEach(key => {
      const td = document.createElement("td");
      const inputPos = document.createElement("input");
      inputPos.type = "text";
      inputPos.setAttribute("list", "positionList");
      inputPos.value = p[key] || "";
      inputPos.style.width = "60px";
      inputPos.oninput = () => {
        const val = inputPos.value.trim().toUpperCase();
        p[key] = POSITION_CATEGORY_ORDER.includes(val) ? val : "";
        savePlayersToStorage();
        renderPlayersTable();
      };
      td.appendChild(inputPos);
      tr.appendChild(td);
    });

    const tdTarget = document.createElement("td");
    const inputTarget = document.createElement("input");
    inputTarget.type = "number";
    inputTarget.step = "0.5";
    inputTarget.min = "0";
    inputTarget.value = p.targetQ;
    inputTarget.style.width = "50px";
    inputTarget.onchange = () => {
      p.targetQ = Number(inputTarget.value) || 0;
      savePlayersToStorage();
    };
    tdTarget.appendChild(inputTarget);
    tr.appendChild(tdTarget);

    const tdStart = document.createElement("td");
    const inputStart = document.createElement("input");
    inputStart.type = "number";
    inputStart.min = "1";
    inputStart.max = "4";
    inputStart.value = p.startQ;
    inputStart.style.width = "40px";
    inputStart.onchange = () => {
      p.startQ = Number(inputStart.value) || 1;
      savePlayersToStorage();
    };
    tdStart.appendChild(inputStart);
    tr.appendChild(tdStart);

    const tdEnd = document.createElement("td");
    const inputEnd = document.createElement("input");
    inputEnd.type = "number";
    inputEnd.min = "1";
    inputEnd.max = "4";
    inputEnd.value = p.endQ;
    inputEnd.style.width = "40px";
    inputEnd.onchange = () => {
      p.endQ = Number(inputEnd.value) || 4;
      savePlayersToStorage();
    };
    tdEnd.appendChild(inputEnd);
    tr.appendChild(tdEnd);

    const tdDel = document.createElement("td");
    const btnDel = document.createElement("button");
    btnDel.className = "icon-btn";
    btnDel.innerHTML = "✕";
    btnDel.title = "선수 삭제";
    btnDel.onclick = () => {
      if (confirm(`${p.name || "이 선수"}를 삭제할까요?`)) {
        const realIdx = players.indexOf(p);
        if (realIdx >= 0) {
          players.splice(realIdx, 1);
          savePlayersToStorage();
          renderPlayersTable();
        }
      }
    };
    tdDel.appendChild(btnDel);
    tr.appendChild(tdDel);

    tbody.appendChild(tr);
  });
}

function renderQuarterCards() {
  const container = document.getElementById("quartersContainer");
  container.innerHTML = "";
  for (let q=1;q<=4;q++) {
    const card = document.createElement("div");
    card.className = "q-card";
    card.id = `cardQ${q}`;
    const h3 = document.createElement("h3");
    h3.innerHTML = `${q}Q <span class="badge" id="badgeQ${q}"></span>`;
    card.appendChild(h3);

    const pitch = document.createElement("div");
    pitch.id = `pitchQ${q}`;
    pitch.className = "pitch";
    card.appendChild(pitch);

    container.appendChild(card);
  }
}

/* =========================
   4. 선수 추가 / 초기화
   ========================= */

function addPlayer() {
  players.push({
    name: "",
    main: "",
    sub1: "",
    sub2: "",
    present: false,
    targetQ: 2,
    startQ: 1,
    endQ: 4,
    allocatedQuarters: 0
  });
  savePlayersToStorage();
  renderPlayersTable();
}

function resetPlayers() {
  if (!confirm("선수 목록을 처음 상태로 되돌릴까요? (현재 저장된 정보는 사라집니다)")) return;
  window.localStorage.removeItem(STORAGE_KEY);
  init();
}

/* =========================
   5. 라인업 생성 로직
   ========================= */

function generateLineup() {
  const playersPerSide = Number(document.getElementById("playersPerSide").value);
  const baseFormationByQuarter = {
    1: document.getElementById("fQ1").value,
    2: document.getElementById("fQ2").value,
    3: document.getElementById("fQ3").value,
    4: document.getElementById("fQ4").value
  };

  currentFormationKeyByQuarter = {};
  for (let q=1;q<=4;q++) {
    currentFormationKeyByQuarter[q] = resolveFormationKey(playersPerSide, baseFormationByQuarter[q]);
  }

  players.forEach(p => { p.allocatedQuarters = 0; });

  const assignedByQuarter = { 1:new Set(), 2:new Set(), 3:new Set(), 4:new Set() };
  let lastGkIndex = null;
  currentSlots = [];

  for (let q=1;q<=4;q++) {
    const formKey = currentFormationKeyByQuarter[q];
    const form = FORMATIONS[formKey];
    if (!form) continue;
    const grid = form.grid;

    for (let r=0; r<grid.length; r++) {
      const row = grid[r];
      for (let c=0; c<row.length; c++) {
        const pos = row[c];
        if (!pos) continue;

        let bestIdx = -1;
        let bestScore = -1e15;

        players.forEach((p, idx) => {
          if (assignedByQuarter[q].has(idx)) return; // 쿼터 내 중복 방지

          const score = scorePlayerForSlotQuarter(p, idx, q, pos, lastGkIndex);
          if (score > bestScore) {
            bestScore = score;
            bestIdx = idx;
          }
        });

        if (bestIdx >= 0 && bestScore > -1e10) {
          currentSlots.push({ quarter: q, row: r, col: c, position: pos, playerIndex: bestIdx });
          players[bestIdx].allocatedQuarters += 1;
          assignedByQuarter[q].add(bestIdx);
          if (pos === "GK") lastGkIndex = bestIdx;
        } else {
          currentSlots.push({ quarter: q, row: r, col: c, position: pos, playerIndex: null });
        }
      }
    }
  }

  updateStatsFromSlots();
  renderResult();
}

/**
 * 점수 계산 (쿼터 내 중복 여부는 generateLineup 에서 이미 제외)
 */
function scorePlayerForSlotQuarter(p, playerIndex, quarter, position, lastGkIndex) {
  if (!p.present) return -1e12;
  if (!p.name) return -1e12;
  if (quarter < p.startQ || quarter > p.endQ) return -1e12;

  const targetQ = p.targetQ || 0;
  if (targetQ <= 0) return -1e12;

  let score = 0;
  const posCat = posCategory(position);
  const mainCat = posCategory(p.main);
  const sub1Cat = posCategory(p.sub1);
  const sub2Cat = posCategory(p.sub2);

  if (position === "GK") {
    if (p.main === "GK") score += 100;
    else if (p.sub1 === "GK" || p.sub2 === "GK") score += 70;

    let gkBase = 0;
    if (p.main === "GK") gkBase = 200;
    else if (p.sub1 === "GK" || p.sub2 === "GK") gkBase = 150;
    score += gkBase;

    if (lastGkIndex === playerIndex) score += 80;
  } else {
    if (posCat && posCat === mainCat) {
      score += 100;
    } else if (posCat && posCat === sub1Cat) {
      score += 70;
    } else if (posCat && posCat === sub2Cat) {
      score += 50;
    } else {
      score += 5;
    }
  }

  const allocated = p.allocatedQuarters || 0;
  const remain = targetQ - allocated;

  if (remain > 0) {
    score += remain * 20;
  } else if (remain < 0) {
    score += remain * 10;
  }

  return score;
}

/* =========================
   6. 결과 렌더링 + 수정 가능 셀
   ========================= */

function isPlayerUsedInQuarter(playerIndex, quarter, exceptSlot) {
  if (playerIndex == null) return false;
  return currentSlots.some(s =>
    s.quarter === quarter &&
    s !== exceptSlot &&
    s.playerIndex === playerIndex
  );
}

function updateStatsFromSlots() {
  players.forEach(p => { p.allocatedQuarters = 0; });
  currentSlots.forEach(s => {
    if (s.playerIndex != null) {
      const p = players[s.playerIndex];
      if (p) p.allocatedQuarters += 1;
    }
  });

  let totalTargetQ = 0;
  let totalAllocatedQ = 0;
  players.forEach(p => {
    if (!p.present || !p.name) return;
    totalTargetQ += (p.targetQ || 0);
    totalAllocatedQ += (p.allocatedQuarters || 0);
  });

  const summary = document.getElementById("summary");
  const diff = totalAllocatedQ - totalTargetQ;
  summary.innerHTML =
    `총 출전: ${totalAllocatedQ}Q / 목표: ${totalTargetQ}Q (차이: ${diff}Q)`;

  const playerQuartersDiv = document.getElementById("playerQuarters");
  const lines = [];
  players.forEach(p => {
    if (!p.present || !p.name) return;
    const qPlayed = p.allocatedQuarters || 0;
    lines.push(`${p.name}: ${qPlayed}Q`);
  });
  playerQuartersDiv.textContent = lines.length
    ? `참석자별 출전 쿼터: ${lines.join(", ")}`
    : "";
}

function renderResult() {
  // 쿼터별 slot 매핑 (row,col → slot)
  const slotMapByQuarter = { 1:{}, 2:{}, 3:{}, 4:{} };
  currentSlots.forEach(s => {
    const key = `${s.row}_${s.col}`;
    slotMapByQuarter[s.quarter][key] = s;
  });

  for (let q=1;q<=4;q++) {
    const formKey = currentFormationKeyByQuarter[q];
    const form = FORMATIONS[formKey];
    const pitch = document.getElementById(`pitchQ${q}`);
    const badge = document.getElementById(`badgeQ${q}`);

    if (!form || !pitch || !badge) continue;

    badge.textContent = form.label;
    pitch.innerHTML = "";

    const grid = form.grid;
    for (let r=0; r<grid.length; r++) {
      const rowDiv = document.createElement("div");
      rowDiv.className = "pitch-row";
      for (let c=0; c<grid[r].length; c++) {
        const pos = grid[r][c];
        const cell = document.createElement("div");
        cell.className = "pitch-cell";

        if (pos) {
          const key = `${r}_${c}`;
          const slot = slotMapByQuarter[q][key];

          const posDiv = document.createElement("div");
          posDiv.className = "pitch-pos";
          posDiv.textContent = pos;
          cell.appendChild(posDiv);

          // 셀렉트 박스 (수정 가능)
          const sel = document.createElement("select");
          sel.style.fontSize = "10px";
          sel.style.marginTop = "2px";

          const optEmpty = document.createElement("option");
          optEmpty.value = "";
          optEmpty.textContent = "-";
          sel.appendChild(optEmpty);

          players.forEach((p, idx) => {
            if (!p.present || !p.name) return;
            const opt = document.createElement("option");
            opt.value = String(idx);
            opt.textContent = p.name;
            if (slot && slot.playerIndex === idx) opt.selected = true;
            sel.appendChild(opt);
          });

          sel.onchange = () => {
            const prevIdx = slot.playerIndex;
            const newVal = sel.value === "" ? null : Number(sel.value);

            if (newVal !== null && isPlayerUsedInQuarter(newVal, q, slot)) {
              alert("같은 쿼터에 한 선수는 한 번만 배정 가능합니다.");
              // 이전 값으로 롤백
              sel.value = prevIdx == null ? "" : String(prevIdx);
              return;
            }

            slot.playerIndex = newVal;
            updateStatsFromSlots();
          };

          cell.appendChild(sel);
        }

        rowDiv.appendChild(cell);
      }
      pitch.appendChild(rowDiv);
    }
  }
}

/* =========================
   7. 초기 실행
   ========================= */
init();
</script>
</body>
</html>
